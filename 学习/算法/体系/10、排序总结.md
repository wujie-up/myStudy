## 1、排序复杂度及稳定性表

| 排序算法 | 时间复杂度  | 空间复杂度 | 稳定性 |
| -------- | ----------- | ---------- | ------ |
| 选择排序 | O(N ^ 2)    | O(1)       | N      |
| 冒泡排序 | O(N ^ 2)    | O(1)       | Y      |
| 插入排序 | O(N ^ 2)    | O(1)       | Y      |
| 归并排序 | O(N * logN) | O(N)       | Y      |
| 随机快排 | O(N * logN) | O(logN)    | N      |
| 堆排序   | O(N * logN) | O(1)       | N      |
|          |             |            |        |
| 计数排序 | O(N)        | O(M)       | Y      |
| 基数排序 | O(N)        | O(N)       | Y      |



## 2、排序算法选择

1）不基于比较的排序，对样本数据有严格要求，不易改写
2）基于比较的排序，只要规定好两个样本怎么比大小就可以直接复用
3）基于比较的排序，时间复杂度的极限是O(N*logN)
4）时间复杂度O(N * logN)、额外空间复杂度低于O(N)、且稳定的基于比较的排序是不存在的。
5）为了绝对的速度选快排、为了省空间选堆排、为了稳定性选归并

## 3、常见的坑

1）归并排序的额外空间复杂度可以变成O(1)，“归并排序 内部缓存法”，但是将变得不再稳定。

2）“原地归并排序" 是垃圾贴，会让时间复杂度变成O(N^2) 

3）快速排序稳定性改进，“01 stable sort”，但是会对样本数据要求更多。

4) 在整型数组中，请把奇数放在数组左边，偶数放在数组右边，要求所有奇数之间原始的相对次序不变，所有偶数之间原始相对次序不变。时间复杂度做到O(N)，额外空间复杂度做到O(1)        -- 无解

## 4、对排序的改进

1)稳定性的考虑 

2)充分利用O(N*logN)和O(N^2)排序各自的优势